package discgo

import (
	"time"

	"encoding/json"

	"path"

	"net/url"
	"strconv"

	"io"
)

// Channel represents a channel in Discord.
// If Recipient is set this is a DM Channel otherwise this is a Guild Channel.
// Guild Channel represents an isolated set of users and messages within a Guild.
// DM Channel represent a one-to-one conversation between two users, outside of the
// scope of guilds.
type Channel struct {
	ID                   string       `json:"id"`
	GuildID              string       `json:"guild_id"`
	Name                 string       `json:"name"`
	Type                 string       `json:"type"`
	Position             int          `json:"position"`
	IsPrivate            bool         `json:"is_private"`
	PermissionOverwrites []*Overwrite `json:"permission_overwrites"`
	Topic                string       `json:"topic"`
	Recipient            *User        `json:"recipient"`
	LastMessageID        string       `json:"last_message_id"`
	Bitrate              int          `json:"bitrate"`
	UserLimit            int          `json:"user_limit"`
}

// Message represents a message sent in a channel within Discord.
// The author object follows the structure of the user object, but
// is only a valid user in the case where the message is generated
// by a user or bot user. If the message is generated by a webhook,
// the author object corresponds to the webhook's id, username, and avatar.
// You can tell if a message is generated by a webhook by checking for the
// webhook_id on the message object.
type Message struct {
	ID              string        `json:"id"`
	ChannelID       string        `json:"channel_id"`
	Author          *User         `json:"author"`
	Content         string        `json:"content"`
	Timestamp       *time.Time    `json:"timestamp"`
	EditedTimestamp *time.Time    `json:"edited_timestamp"`
	TTS             bool          `json:"tts"`
	MentionEveryone bool          `json:"mention_everyone"`
	Mentions        []*User       `json:"mentions"`
	MentionRoles    []string      `json:"mention_roles"`
	Attachments     []*Attachment `json:"attachments"`
	Embeds          []*Embed      `json:"embeds"`
	Reactions       []*Reaction   `json:"reactions"`
	Nonce           string        `json:"nonce"`
	Pinned          bool          `json:"pinned"`
	WebhookID       string        `json:"webhook_id"`
}

type File struct {
	Name    string
	Content io.Reader
}

type Reaction struct {
	Count int
	Me    bool
	Emoji *ReactionEmoji
}

type ReactionEmoji struct {
	ID   *string // nullable
	Name string
}

type Overwrite struct {
	ID    string
	Type  string
	Allow int
	Deny  int
}

type Embed struct {
	Title       string
	Type        string
	Description string
	URL         string
	Timestamp   time.Time
	Color       int
	Footer      *EmbedFooter
	Image       *EmbedImage
	Thumbnail   *EmbedThumbnail
	Video       *EmbedVideo
	Provider    *EmbedProvider
	Author      *EmbedAuthor
	Fields      []*EmbedField
}

type EmbedThumbnail struct {
	URL      string
	ProxyURL string
	Height   int
	Width    int
}

type EmbedVideo struct {
	URL    string
	Height int
	Width  int
}

type EmbedImage struct {
	URL      string
	ProxyURL string
	Height   int
	Width    int
}

type EmbedProvider struct {
	Name string
	URL  string
}

type EmbedAuthor struct {
	Name         string
	URL          string
	IconURL      string
	ProxyIconURL string
}

type EmbedFooter struct {
	Text         string
	IconURL      string
	ProxyIconURL string
}

type EmbedField struct {
	Name   string
	Value  string
	Inline bool
}

type Attachment struct {
	ID       string
	Filename string
	Size     int
	URL      string
	ProxyURL string
	Height   int
	Width    int
}

// TODO create mention method on User, Channel, Role and Custom ReactionEmoji structs
// https://discordapp.com/developers/docs/resources/channel#message-formatting

const endpointChannels = "channels"

func endpointChannel(cID string) string {
	return path.Join(endpointChannels, cID)
}

func (c *Client) GetChannel(cID string) (ch *Channel, err error) {
	endpoint := endpointChannel(cID)
	req, err := c.newRequest("GET", endpoint, nil)
	if err != nil {
		return nil, err
	}
	body, err := c.do(req, endpoint, 0)
	if err != nil {
		return nil, err
	}
	return ch, json.Unmarshal(body, &ch)
}

type ModifyChannel struct {
	Name      string `json:"name,omitempty"`
	Position  int    `json:"position,omitempty"`
	Topic     string `json:"topic,omitempty"`
	Bitrate   int    `json:"bitrate,omitempty"`
	UserLimit int    `json:"user_limit,omitempty"`
}

func (c *Client) ModifyChannel(cID string, chm *ModifyChannel) error {
	endpoint := endpointChannel(cID)
	req, err := c.newRequestJSON("PATCH", endpoint, chm)
	if err != nil {
		return err
	}
	_, err = c.do(req, endpoint, 0)
	return err
}

func (c *Client) DeleteChannel(cID string) (ch *Channel, err error) {
	endpoint := endpointChannel(cID)
	req, err := c.newRequest("DELETE", endpoint, nil)
	if err != nil {
		return nil, err
	}
	body, err := c.do(req, endpoint, 0)
	if err != nil {
		return nil, err
	}
	return ch, json.Unmarshal(body, &ch)
}

func endpointChannelMessages(cID string) string {
	return path.Join(endpointChannel(cID), "messages")
}

type GetChannelMessages struct {
	AroundID string
	BeforeID string
	AfterID  string
	Limit    int
}

func (c *Client) GetChannelMessages(cID string, gcms *GetChannelMessages) (msgs []*Message, err error) {
	endpoint := endpointChannelMessages(cID)
	req, err := c.newRequest("GET", endpoint, nil)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	if gcms.AroundID != "" {
		v.Set("around", gcms.AroundID)
	}
	if gcms.BeforeID != "" {
		v.Set("before", gcms.BeforeID)
	}
	if gcms.AfterID != "" {
		v.Set("after", gcms.AfterID)
	}
	if gcms.Limit > 0 {
		v.Set("limit", strconv.Itoa(gcms.Limit))
	}
	if len(v) > 0 {
		req.URL.RawQuery = v.Encode()
	}

	body, err := c.do(req, endpoint, 0)
	if err != nil {
		return nil, err
	}
	return msgs, json.Unmarshal(body, &msgs)
}

func endpointChannelMessage(cID, mID string) string {
	return path.Join(endpointChannelMessages(cID), mID)
}

func (c *Client) GetChannelMessage(cID, mID string) (m *Message, err error) {
	endpoint := endpointChannelMessage(cID, mID)
	req, err := c.newRequest("GET", endpoint, nil)
	if err != nil {
		return nil, err
	}
	rateLimitPath := endpointChannelMessage(cID, "{id}")
	body, err := c.do(req, rateLimitPath, 0)
	if err != nil {
		return nil, err
	}
	return m, json.Unmarshal(body, &m)
}

type CreateMessage struct {
	Content string
	Nonce   string
	TTS     bool
	File    *File
	Embed   *Embed
}

func (c *Client) CreateMessage(cID, cm *CreateMessage) (m *Message, err error) {
	panic("TODO")
}
